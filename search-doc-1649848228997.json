[{"title":"History","type":0,"sectionRef":"#","url":"history","content":"History","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"introduction","content":"Introduction","keywords":""},{"title":"ReDeNS — Reverse DeCert (TIP-2.1)","type":0,"sectionRef":"#","url":"Standard/TIP-2/1","content":"ReDeNS — Reverse DeCert (TIP-2.1) In TIP-2 it is stated that in order to resolve a Certificate Address from the Contract Address, that contract must have its Certificate Address explicitly stated. There is a need sometimes to resolve some certificate address from the address of a contract. Here we present an architecture and implementation of Reverse DeCert and one of its usecases: ReDeNS Reverse Decentralized Names or ReDeNS for short is a certificate that enables reverse resolving of some contracts addresses from another contract. It uses a contract Placeholder for each type of contract functionality that we want to be able to put into external (or satellite) contract of a main contract. ReDeNs enables any client to calculate the address of a satellite contract using a ReDeNs code as a certificate for each type of satellite contract it desires to resolve. In order to resolve a ReDeNS address the user may calculate an address taking a hash of a main contract and a hash of ReDeNS certificate as initial data and an owner address or PubKey in constructor parameters. After the deploy of initial ReDeNS certificate code developer will use SetCode to change the ReDeNS certificate code to desired type of satellite smart contract (with ABI, Getter or DeBot functionality, respectively and so on) For example we have identified 3 types of satellite contracts which will be default ReDeNS Certificates of any main contract in Solidity and C++ Compilers and TON OS SDK: ABI, GETTERS and DEBOT. To protect contracts without ReDeNS certificate deployed from squatters we propose to use header with bitmask: one bit for each type of ReDeNS certificates: abi-DeCert, getters-DeCert, debot-DeCert and so on. So far, we decided to have 16-bit bitmask. 3 of them already occupied. { Abi, getters, debot }. The ReDeNS certificate code is as following: How to create DeBot derived from your smart contract","keywords":""},{"title":"Non-fungible token payment link (TIP-5.2)","type":0,"sectionRef":"#","url":"Standard/TIP-5/2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"Standard/TIP-5/2#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"Standard/TIP-5/2#motivation","content":"TDB "},{"title":"URI scheme","type":0,"sectionRef":"#","url":"Standard/TIP-5/core-description","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"URI scheme","url":"Standard/TIP-5/core-description#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"URI scheme","url":"Standard/TIP-5/core-description#motivation","content":"TDB "},{"title":"End-to-end Decentralization","type":0,"sectionRef":"#","url":"Decentralize/end-to-end-decentralization","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"End-to-end Decentralization","url":"Decentralize/end-to-end-decentralization#background","content":"Decentralization is an important property of public blockchain technology 1. Despite its claims of decentralization, blockchain keeps on fighting to achieve it through improvements and optimizations mainly related to consensus mechanisms and data exchange protocols. Proof-of-Work and Proof-of-Stake consensus protocols (and their derivatives) have issues related to centralization at both mining/staking and at the front-end levels. Considerable amounts of centralization exist in development ecosystems of some blockchains as well. Decentralization claims can only be made when the whole system is decentralized, and therefore, should be judged by its weakest (or rather most centralized) link. In the current invention we present an end-to-end Decentralization framework (E2ED). In today's blockchains that support smart contracts (or in other words the ability to perform and validate arbitrary computations), user interaction with results of such computations is performed using some front end library (such as Web3 in Ethereum blockchain). The Web3 library takes care of performing blockchain related tasks with blockchain data presented to a user. The IPFS is used to store data in a decentralized manner. Yet as shown below neither is enough to preserve full decentralization of end user interactions with a blockchain system to ensure censorship resistance and security. "},{"title":"Web3​","type":1,"pageTitle":"End-to-end Decentralization","url":"Decentralize/end-to-end-decentralization#web3","content":"Web3.0 js is a collection of libraries which allow you to interact with a local or remote Ethereum node, using a HTTP or IPC connection2. Web3.0 is a collection of JavaScript libraries that allow users to interact with a local or remote Ethereum node using an HTTP or IPC connection. In other words, it’s a kind of SDK which gives users the ability to work with blockchain in the browser. That’s why it actually has a Web in the name and not something else. Web3.0 is numbered 3.0 quite obviously because 2.0 and 1.0 versions of Web already exist, referring to the World Wide Web's evolution where the 2.0 version unlike the 1.0 version, for instance, allows for display of user-generated content, dynamically making websites more sophisticated. Web 3.0 on the other hand is seen as part of the World Wide Web’s evolution due to the fact that it can be considered as a first attempt to access decentralized (blockchain) applications on the web. The purpose of Web3 is to give the ability to create decentralized apps on the web connecting sites to the world of blockchain, in particular Ethereum blockchain. The main problem with this approach is that a user does not really interact with the blockchain when using Web3 based applications, because most of the time the user interacts with many elements of information outside of the blockchain, presented to them by the application user interface. This presents quite a significant problem as all such information and user interface elements are not decentralized, which means they are not immutable, not censorship resistant, and not fault tolerant. Moreover, blockchain related elements that are supposedly temper proofed lose their properties once they are part of this centralized model. "},{"title":"IPFS​","type":1,"pageTitle":"End-to-end Decentralization","url":"Decentralize/end-to-end-decentralization#ipfs","content":"Enters IPFS. The InterPlanetary File System (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices3. An IPFS developer or user can store the content somewhere that’s always online and accessible and make sure that when the user comes online they know where to find the content. This way we theoretically could use IPFS to store all user interfaces somewhere, save a hash and an address of said content on the blockchain and therefore prove to the user that whatever is displayed in their browser is true and correct by way of verifying it using Web3 library. Yet even an IPFS and Web3 combination does not guarantee end-to-end decentralization as described below in more detail. "},{"title":"User interaction (DeBot)​","type":1,"pageTitle":"End-to-end Decentralization","url":"Decentralize/end-to-end-decentralization#user-interaction-debot","content":"A system is needed to create a comprehensive user experience without relying on trusted infrastructure. To achieve this, we introduced technology for writing the user interface inside the smart contract itself. Decentralized Bot (DeBot) is a technology enabling end-to-end Decentralization at a user interaction level. Using E2ED, any front-end application (be it in a web browser or a purposely built software) can draw an entire user experience without relying on a server. Comparing Web 2.0, Web 3.0 and E2ED based systems (which for the purpose of the diagram below we named Web3.11 as a reminiscent to the famous Windows 3.11), E2ED is not a contradiction to Web3.0 but rather a continuation that closes some centralization loopholes to achieve end-to-end decentralization. Web3.0 itself is not a monolithic system. It has many components such as an IPFS database for storage and others for address discovery and storage query on top. The Web3.0 approach is fragmented. A smart contract is executed in one place and the data it manipulates is stored in another. The data meets the business logic only on an end user device, therefore, the computation performed on such data can not be verified by a blockchain. For that reason we have verifiable business logic (smart contract) operating with the data it can not verify. The only limited verification available is the hash of data stored somewhere else. The interaction with said data is static. If a man-in-the-middle attack is performed on the user device level, the security of Web3 can be compromised. In practice today what happens in almost 100% of cases is shown in the middle column of the diagram below. A user interface is provided by a web server. An application is running on the server and displayed in the user browser (or on a mobile device). The user performs many usual operations with the website content on the server and only when needed to interact with the blockchain does the Web3.0.js get called, which then interacts with the blockchain calling it from the end user device and signed with the user private key. Even if Web3.0 is really advanced and stores the application data (say a website), in the IPFS database the Web3.0.js will be called to perform operations with a blockchain and again not the library nor the smart contract it interacts with, and will not be able to verify what has actually happened to the data that was stored and received from the IPFS on the user device.  In E2ED the smart contract contains the actual user interface in a form of DeBot. The DeBot system described herein is just one way of performing user interface functions by a smart contract. The whole graphical user interface could be drawn if needed. In DeBot the sequence of user actions is performed by calling DeBot smart contract functions using the local virtual machine of any particular blockchain. The result of those actions could at any time be transmitted to the remote smart contract together with the sequence of user performed actions and the whole interface interaction could be verified remotely by the blockchain, including the resulting transaction. In terms of addressing the user, it just needs to know the address of a smart contract DeBot, which is a blockchain address that in turn can be abstracted further using a blockchain based DNS service. "},{"title":"References​","type":1,"pageTitle":"End-to-end Decentralization","url":"Decentralize/end-to-end-decentralization#references","content":"The Meaning of Decentralization↩web3.js - Ethereum JavaScript API↩InterPlanetary File System↩ "},{"title":"Free Software License (TIP-1.1)","type":0,"sectionRef":"#","url":"Standard/TIP-1/1","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"Standard/TIP-1/1#introduction","content":"Many members of our community have asked questions about Free TON code philosophy. Why we call it Free Software? What is a relationship between Free TON and Free Software? What is the difference between Free Software and Open Source? I have decided to combine this with an idea I have regarding gas payment redistribution in TON. You will see below why it is related. The concept of Free Software predates open source. Richard Stallman has started the free-software movement in 1983 with a launch of GNU Project while open-source movement has been derived from Free Software only in 1998. To clarify, the Free Software is not in conflict with Open Source. As explained below it follows all the same principles and the differences seems more ideological. Yet TON project did not have any problem with open-source nature of it software. It is all open sourced. The problem was exactly about the Freedom of people to use it. That is why Free TON is heavily influenced by Free Software movement. Declaration of Decentralisation is, in many ways, inspired by Stallman’s «The GNU Manifesto»1. In «Why Open Source misses the point of Free Software» Stallman writes among other things: «The terms «free software» and «open source» stand for almost the same range of programs. However, they say different things about those programs, based on different values. The free software movement campaigns for freedom for the users of computing; it is a movement for freedom and justice. By contrast, the open source idea values mainly practical advantage and does not campaign for principles. This is why we do not agree with open source, and do not use that term»2. It seems Free TON is in agreement with this line of thought. While all our software is open source it is the Freedom to run the software what has launched this network. Now let’s talk about Copyright and Licensing as they relate to the Free Software in general and Blockchain in particular. Before we start I need to say that blockchain may potentially provide a solution to some of the free software inherited business model problems. We all remember that free in the free software stands for freedom and not for zero price. The ability to get paid for a software should not be based on restrictions imposed by its license. But what it should be based upon then? There are several business models for free software non of which really works. What works is a business model that is not exactly related to the software itself and therefore can not be attributed to it. Such as charging for support or for portions of the software which are closed source. It all seems quite unnatural. It also prevents one of the major points of free software — an open collaboration of the community around software projects. Donald Fischer article title «Open source creators: Red Hat got $34 billion and you got $0. Here’s why»3 is self explanatory. IBM has bought a commercial company that was built on top of many developers’ contribution to its code. Those developers never got any part out of the value they have created. "},{"title":"Aligning the incentives​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"Standard/TIP-1/1#aligning-the-incentives","content":"Many free and open source software projects struggle to introduce a sustainable business model. This is one of the reasons why most of the open source software contributors work for large corporations. When a venture capital provides funding to a software project it expects multiple return on its capital. With commercial software it is quite straight forward — a company is charging money for its software use and if successful passes profits to its stakeholders. With free software its quite difficult. That is why there are very few (or should we say: not enough) commercially successful open source software companies. Blockchain introduces a unique opportunity for Free Software developers to align their commercial interests with those of users for the benefit of the whole ecosystem. As an Internet of Value protocol, Blockchain has built-in network incentive mechanism — network fees (or gas). To remind: Miners in Proof-Of-Work collect miner rewards and network fees to compensate them for resources spent to secure the network and process transactions. Both security computations and transaction processing are separate resources, thus requiring separate fees. In Proof-Of-Stake Validators commit funds and processing power to secure the network and process transactions (in a form of smart contract execution in TON). For this they also get separate rewards: block rewards in a form of token emission and transaction reward in a form of a fee. Please note, rewards are separated in both cases. We propose to extend the reward model to transaction facilitators. It would be logical to pay part of the fees to the smart contract developer who is initiating the transaction which pays the fee. This will attract both Developers and Users which will increase network usage and total transaction fees for all network participants. "},{"title":"On-chain licensing fees​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"Standard/TIP-1/1#on-chain-licensing-fees","content":"Somewhat naive mechanism but with the same underlying idea is proposed by Near blockchain. «The developerReward are allocated by per block per account, as they can be efficiently done every time the transaction or receipts is being processed by the contract»4. The problem with this approach lays in the fact that network fees not only pays for resources but also provide an important anti spam mechanism. One can use the developer kick-back to simply lower an attack costs. To mitigate that risk we propose a use of a special Payout Contract. This contract is going to pay the collected Copyleft fees to developers only after certain threshold in both amount of fees and time frame are surpassed. In this respect the Developer motivation is again aligned with the Network security model — it is not practical to break the network where one receives a long term rent. "},{"title":"Some technical details​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"Standard/TIP-1/1#some-technical-details","content":"Technically we introduce a TVM Opcode FB0A. Contract may include that code together with a License information and address of its developer. Collator will include a reward related to gas fees from these transactions into the block for the address indicated in the TVM instruction in the amount corresponding to the indicated License. The percentage of gas fees depends on the license type such as that the most free software compatible license provides more gas. FB0A - COPYLEFT (n x y - ), looks up for the license rule for ‘n’ in ConfigParam (for example 42) and creates output action to send part of the tokens it collected from gas fees to Payout contract indicated in ConfigParam for address x:y, where x - is 32 bit signed integer for workchain and y is 256 bit unsigned integer for contract address in this workchain. It will not throw any exceptions if n or the address are incorrect. Generally allowed licenses are those supported by Free Software Foundation as described here: https://www.gnu.org/licenses/license-list.html#SoftwareLicenses 2 License types payout GPL-Compatible Free Software Licenses 2 → 30% fees GPL-Incompatible Free Software Licenses → 20% fees To implement we add network config parameter: license fees threshold value Collator check threshold each time the instruction is executed. After threshold is reached collator sends value to Developer Account defined in contract instruction FB0A TVM creates special out action with Developer Account (last call of FB0A matters) If account is been deleted, the executor sends value to Developer Account or to ValueFlow if it is not enough (this case must be checked in Validator) Executor analyzes special out action and counts value then sends message to developer account (payment for transaction gets from value) We add fields to json objects and QServer for SDK Collator and Validator must check fees from ValueFlow with Developer correction "},{"title":"Copyright discussion​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"Standard/TIP-1/1#copyright-discussion","content":"«What is the proper way to decide copyright policy? If copyright is a bargain made on behalf of the public, it should serve the public interest above all. The government’s duty when selling the public’s freedom is to sell only what it must, and sell it as dearly as possible. At the very least, we should pare back the extent of copyright as much as possible while maintaining a comparable level of publication»5. One important dimension of copyright is its durationAnother dimension of copyright policy is the extent of fair use: some ways of reproducing all or part of a published work that are legally permitted even though it is copyrighted. (c) Richard Stallman Both duration and fair use of copyright is balanced in this proposal by virtue of compensating copyright holder by Payout Contract creating an ongoing reward from the network while at the same time not preventing a forking possibility by other developers who then need to improve the software in a way that will bring new users and create new intensive for the new contributor. So both improvements as well as long term rent (subscription) is provided for developers. The Copyleft spirit is fully supported here as the Fee is collected for developers who facilitates the fees creation in the first place. The freedom to fork is fully executed as well as anyone can fork the code of a smart contract. In the end it is the community of users who chooses which contract to use and the decision is usually based upon the reputation of the code represented by the hash of the code where is no single byte has been changed. Therefore the system is merit-based. Both long term developer’s incentives for original developers and forking is provided. To recap the proposed system is compatible with all four essential freedoms: The freedom to run the program as you wish, for any purpose (freedom 0).The freedom to study how the program works, and change it so it does your computing as you wish (freedom 1). Access to the source code is a precondition for this.The freedom to redistribute copies so you can help others (freedom 2).The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this. "},{"title":"References​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"Standard/TIP-1/1#references","content":"The GNU Manifesto↩Why Open Source Misses the Point of Free Software↩Open source creators: Red Hat got $34 billion and you got $0. Here's why↩Economics in a Sharded Blockchain — Section 06 — Developer Business Models↩Misinterpreting Copyright — A Series of Errors↩ "},{"title":"Standard Interface Detection","type":0,"sectionRef":"#","url":"Standard/TIP-6/core-description","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection","url":"Standard/TIP-6/core-description#abstract","content":"Smart contracts in Everscale can implement a wide variety of functionality - wallets, tokens, exchanges and so on. We need a standard way to determine the type of smart contract without relying on knowledge of its internal structure. "},{"title":"Terminology","type":0,"sectionRef":"#","url":"terminology","content":"Terminology","keywords":""},{"title":"Workflow (TIP-0)","type":0,"sectionRef":"#","url":"Standard/workflow","content":"Workflow (TIP-0) TIP — Trustless Improvement Proposal (TIPs) describe standards for the Everscale blockchain. They may include anything that the community considers in need of improvement or standardization. That can be specifications for core protocol, description of interfaces, smart contract standards and so on. I propose a more relaxed structure more closely resembling Bitcoin BIPs but with quite different proccess (see below). Each TIP should have the following parts (which are heavily copy-pasted from BIP requirements): Preamble — Headers containing metadata about the TIP;Abstract — A short (~200 word) description of the technical issue being addressed;Copyright — The TIP must be explicitly licensed under acceptable copyright terms;Specification — The technical specification should describe the syntax and semantics of any new feature;The specification should be detailed enough to allow competing, interoperable implementations;Motivation — The motivation is critical for TIPs that want to change the Everscale protocol. It should clearly explain why the existing protocol is inadequate to address the problem that the TIP solves;Rationale — The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion;Backwards compatibility — All TIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The TIP must explain how the author proposes to deal with these incompatibilities; Each TIP should pass the following process of acceptance: Proposal → Discussion → Community Voting → Reference Implementations Contest → Final TIP with Reference Implementations Reference implementation — The reference implementation must be completed before any TIP is given status Final, but it need not be completed before the TIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the Everscale protocol.","keywords":""},{"title":"Non-Fungible Token (TIP-4.1)","type":0,"sectionRef":"#","url":"Standard/TIP-4/1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"Standard/TIP-4/1#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"Standard/TIP-4/1#motivation","content":"TDB "},{"title":"Everscale Wallet Guide","type":0,"sectionRef":"#","url":"wallet-guide","content":"Everscale Wallet Guide","keywords":""},{"title":"Standard Interface Detection Interface (TIP-6.1)","type":0,"sectionRef":"#","url":"Standard/TIP-6/1","content":"","keywords":""},{"title":"Simple summary​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"Standard/TIP-6/1#simple-summary","content":"Creates a standard method to publish and detect what interfaces a smart contract implements. "},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"Standard/TIP-6/1#abstract","content":"Herein, we standardize the following: How interfaces are identifiedHow a contract will publish the interfaces it implements "},{"title":"Motivation​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"Standard/TIP-6/1#motivation","content":"For some “standard interfaces” like the token interface, it is sometimes useful to query whether a contract supports the interface and if yes, which version of the interface, in order to adapt the way in which the contract is to be interacted with. This proposal standardizes the concept of interfaces and standardizes the identification (naming) of interfaces. "},{"title":"Specification​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"Standard/TIP-6/1#specification","content":""},{"title":"How interfaces are identified​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"Standard/TIP-6/1#how-interfaces-are-identified","content":"For this standard, an interface is a set of function selectors as defined by the Solidity ABI. This a subset of Solidity’s concept of interfaces and the interface keyword definition which also defines return types, mutability and events. We define the interface identifier as the XOR of all function selectors in the interface. This code example shows how to calculate an interface identifier: Solidity​ interface Solidity101 { function hello() external pure; function world(int) external pure; } contract Selector { function calculateSelector() public view returns (bytes4) { Solidity101 i; return bytes4(tvm.functionId(i.hello) ^ tvm.functionId(i.world)); } }  How a Contract will Publish the Interfaces it Implements​ A contract that is compliant with TIP6.1 shall implement the following interface: Solidity​ interface TIP6 { /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as specified in TIP6.1 /// @dev Interface identification is specified in TIP6.1. /// @return `true` if the contract implements `interfaceID` and /// `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface(bytes4 interfaceID) external view responsible returns (bool); }  The interface identifier for this interface is 0x3204EC29. You can calculate this by running tvm.functionId('supportsInterface(bytes4)'); or using the Selector contract above. Therefore, the implementing contract will have a supportsInterface function that returns: true when interfaceID is 0x3204EC29 (TIP6.1 interface)false when interfaceID is 0xfffffffftrue for any other interfaceID this contract implementsfalse for any other interfaceID "},{"title":"References​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"Standard/TIP-6/1#references","content":"EIP-165: Standard Interface Detection "},{"title":"Fungible token payment link (TIP-5.1)","type":0,"sectionRef":"#","url":"Standard/TIP-5/1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"Standard/TIP-5/1#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"Standard/TIP-5/1#motivation","content":"TDB "},{"title":"Tutorial Intro","type":0,"sectionRef":"#","url":"intro","content":"","keywords":""},{"title":"Prerequisite​","type":1,"pageTitle":"Tutorial Intro","url":"intro#prerequisite","content":"Node.js &gt;= 14.x installed Node Version Manager (NVM)NVM-windows Docker &gt;= 19.x installed and running "},{"title":"Generate a new project​","type":1,"pageTitle":"Tutorial Intro","url":"intro#generate-a-new-project","content":"mkdir my-project &amp;&amp; cd $_ npm init --force npm install --save everdev  "},{"title":"Setup local environment​","type":1,"pageTitle":"Tutorial Intro","url":"intro#setup-local-environment","content":"Set Local Blockchain SE (Startup Edition) as the default network: Startup SE at this step, you may have to wait until the docker image is downloaded: npx everdev se start  A local network explorer is available at localhost check it. Setting SE as default network: npx everdev network default se  "},{"title":"Configure Giver​","type":1,"pageTitle":"Tutorial Intro","url":"intro#configure-giver","content":"Configure Giver wallet that will sponsor EVER for deploy operation: npx everdev signer add giver 172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3 npx everdev network giver se 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver npx everdev network giver dev 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver  "},{"title":"Generate the key pair for contract ownership​","type":1,"pageTitle":"Tutorial Intro","url":"intro#generate-the-key-pair-for-contract-ownership","content":"Key pair file — used in contracts with implemented authorization. It is the file containing private and public keys authorized to access the contract. In --sign parameter the corresponding seed phrase may be used instead of it. npx everdev signer generate coder npx everdev signer default coder npx everdev signer list  "},{"title":"Generate a new smart-contract​","type":1,"pageTitle":"Tutorial Intro","url":"intro#generate-a-new-smart-contract","content":"npx everdev sol create App  You are got App.sol: pragma ton-solidity &gt;= 0.35.0; pragma AbiHeader expire; // This is class that describes you smart contract. contract App { // Contract can have an instance variables. // In this example instance variable `timestamp` // is used to store the time of `constructor` // or `touch` function call. uint32 public timestamp; // Contract can have a `constructor`. // The function that will be called when contract will be deployed to the blockchain. // In this example constructor adds current time to the instance variable. // All contracts need call `tvm.accept()` for succeeded deploy. constructor() public { // Check that contract's public key is set require(tvm.pubkey() != 0, 101); // Check that message has signature (msg.pubkey() is not zero) and // message is signed with the owner's private key require(msg.pubkey() == tvm.pubkey(), 102); // The current smart contract agrees to buy some gas to finish the // current transaction. This actions required to process external // messages, which bring no value (hence no gas) with themselves. tvm.accept(); timestamp = now; } function renderHelloWorld () public pure returns (string) { return 'helloWorld'; } // Updates variable `timestamp` with current blockchain time. function touch() external { // Each function that accepts external message must check that // message is correctly signed. require(msg.pubkey() == tvm.pubkey(), 102); // Tells to the TVM that we accept this message. tvm.accept(); // Update timestamp timestamp = now; } function sendValue(address dest, uint128 amount, bool bounce) public view { require(msg.pubkey() == tvm.pubkey(), 102); tvm.accept(); // It allows to make a transfer with arbitrary settings dest.transfer(amount, bounce, 0); } }  For more about Solidity and specific of Everscale Solidity "},{"title":"Compile smart-contract​","type":1,"pageTitle":"Tutorial Intro","url":"intro#compile-smart-contract","content":"npx everdev sol compile App.sol  You are got: App.abi.json — ABI *.abi.json file — a file that describes the contract interface, the methods and parameters used to interact with it, for detail see ABI Specification V2.App.tvc — TVC *.tvc file — the compiled smart contract file. Used only when generating contract address and deploying contract code to the blockchain. "},{"title":"Deploy smart-contract​","type":1,"pageTitle":"Tutorial Intro","url":"intro#deploy-smart-contract","content":"The 1 EVER is 1000000000 nano EVER Local network: npx everdev contract deploy --network se --value 1000000000 App  Developer network: npx everdev contract deploy --network dev --value 1000000000 App  "},{"title":"Address smart-contract​","type":1,"pageTitle":"Tutorial Intro","url":"intro#address-smart-contract","content":"Address of smart-contract is calculated from TVC and signer (coder) public: npx everdev contract info --network se --signer coder App  Getting only address: appAddress=$(npx everdev contract info --network se --signer coder App | grep Address | cut -d ' ' -f 4) echo $appAddress  "},{"title":"Interact with smart-contract​","type":1,"pageTitle":"Tutorial Intro","url":"intro#interact-with-smart-contract","content":"Read: npx everdev contract run-local --network se App renderHelloWorld npx everdev contract run-local --network se App timestamp  Write: npx everdev contract run --network se --signer coder App touch  For more details see: Get started with Development Tools. "},{"title":"Fungible Token","type":0,"sectionRef":"#","url":"Standard/TIP-3/core-description","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token","url":"Standard/TIP-3/core-description#abstract","content":"The following standard describes the basic idea about distributed fungible token architecture. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token","url":"Standard/TIP-3/core-description#motivation","content":"The suggested standard differs considerably from Ethereum ERC20 and other smart contract token standards with single registry due to its distributed nature related to Everscale blockchain particularities. Given that Everscale has a storage fee, using an existing ERC20 standard design would cause excessive maintenance costs. Also, ERC20 is somewhat incompatible with the sharding architecture. Therefore, a Distributed Token standard is preferable. The ERC20 sharding implementation (with an idea to simply shard its registry) has drawbacks mainly related to complicated and expansive management. TIP-3 is fully distributed and implies separate storage of each user’s balance. "},{"title":"Architecture​","type":1,"pageTitle":"Fungible Token","url":"Standard/TIP-3/core-description#architecture","content":"General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token","url":"Standard/TIP-3/core-description#token-root","content":"Token root contract stores the general information about the token, e.g. name, symbol, decimals, token wallet code and so on. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token","url":"Standard/TIP-3/core-description#token-wallet","content":"Each token holder has its own instance of token wallet contract. Transfer happens in a decentralized fashion - sender token wallet SHOULD send the specific message to the receiver token wallet. Since token wallets have the same code, it's easy for receiver token wallet to check the correctness of sender token wallet. "},{"title":"References​","type":1,"pageTitle":"Fungible Token","url":"Standard/TIP-3/core-description#references","content":"EIP-20: Token StandardForum FreeTON - TIP3Reference implementation by Broxus "},{"title":"Non-Fungible Token","type":0,"sectionRef":"#","url":"Standard/TIP-4/core-description","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token","url":"Standard/TIP-4/core-description#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token","url":"Standard/TIP-4/core-description#motivation","content":"TDB "},{"title":"DeCert — Decentralized Certificates","type":0,"sectionRef":"#","url":"Standard/TIP-2/core-description","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#abstract","content":"There is a clear need for unified decentralized and distributed certificate system in Free TON. As described in more details below, such system would be used in providing many services which requires a certified provable key-value store. For example a Decentralized Name Service (DeNS), a Prove of Ownership / Prove of Purchase certificate and many others. Current solutions (for example a TON DNS, proposed here) are either a large smart contracts which maintains a full list of records, or a tree-like solutions which shards the list based on some parameters. Neither of these solutions are satisfactory due to a lack of scalability, high costs of maintenance, long search time, single point of failure and so on. Here I present a completely distributed system, which does not require centralized record, nor a tree of domains or records with almost zero latency. The design relies heavily onе the principles of TIP-3 Token architecture with some notable modifications. "},{"title":"Issuance​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#issuance","content":"Root is a smart contract contains a Code of Certificate smart contract without data. The Root has methods for Certificate Issuance, Certificate Code Retrieval, Root PubKey retrieval and Version history. Each Certificate can become a Root, therefore a Root smart contract and its Certificate smart contract are the same. The Code contains an address of its Root. When a User wishes to register it is calling a Certificate Issuance method in Root, sending a Certificate Data (for example an alphanumeric string of a certificate body). Root is taking its Public Key and a Code of Certificate smart contract, inserts a Certificate Data sent by a User, calculates the address of Certificate and checks if the address already has a Certificate or any other Code deployed by sending a bounced true message calling getData method. If a contract exists it means that a Certificate with the same Certificate Data already exists. The contract then can return a registration information to the Root which will return it to a User. If a contract does not exist the message will bounce to the Root smart contract which will mean the Certificate can be registered. If Certificate does not exist the Root will Issue the Certificate by deploying the Certificate Contract with its Data. On deploy the Certificate will check that it has been deployed from the root address by comparing the address of a Root inside with the deployer address. If there is no match the deploy will fail. Of course additional business logic steps could be included between the last two steps, such as monetization or other mechanics as shown below in one of the examples. "},{"title":"Resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#resolving","content":"To resolve the Name any User can now call Get method Resolve of a Root locally to obtain an Address. Root will use Certificate Code, Root PubKey, insert a name User wishes to resolve into Certificate Code and calculate the address. To resolve a Root smart contract one can take any Certificate Core and resolve for the Root name. A user application can cash the Certificate Code smart contract and Root PubKey once, after which resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. The Certificate itself contains variable types of addresses of a target smart contracts to which the Certificate owner wishes the name to point. A user should choose which type of address they wish to use. "},{"title":"Reverse resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#reverse-resolving","content":"In order to make a reverse resolving a smart contract need to state its certificate address. The user will check if certificate indeed has contract address. "},{"title":"Search​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#search","content":"Of course search is one of the most important features of any name system. Knowing a Certificate Code hash enables to retrieve all smart contracts having the same hash by simply querying the blockchain state. Decoding contract data will produce a full list of names under specific Root. It would be quite easy to produce a table with all the certificate records. "},{"title":"Example: Decentralized Name Service (DeNS)​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#example-decentralized-name-service-dens","content":"Let’s consider a DeNS Root is a smart contract which contains a Code of the Name Identity Certificate (NIC) smart contract. The Root has methods for Identity Registering, NIC Code Retrieval, Root PubKey retrieval, Version history. When a User wishes to register an Identity it is calling a «RegName» method in DeNS Root with the signed message of UTF-8 string (Name) together with a Registration Bid (a hash of a Bid Value in TONs with some salt) with value attached 1 TON. DeNS Root is taking its Public Key and a NIC Code inserts a Name, calculates the NIC address and checks if the address already has a NIC Code deployed by sending a bounced true message calling method «getName». Return to User a Whois Information. If it bounces or a registration period in Whois is less than 28 days DeNS Root will send the name into an Auction Smart Contract together with a Registration Bid Hash and a number of years before expiration. First bidder determines the duration of the auctioned name. Other users will be able to Bid for the same name but only for same duration with their Bids following exactly the same process. Auction duration is minimum 7 days per year of name duration but no more than 28 days. At the end of the Auction all participants will submit to the Auction contract a message signed from the address of the original bid together with their original bid price and salt. The winner of the auction will be determined by the highest bid per day and will pay the second higher price for the Name Certificate. Once DeNS Root knows the Auction result it will wait until registration period ends if the name certificate has existed before or immediately deploy the NIC smart contract into the address calculated as a NIC Contract Code with a Name inserted into initial data and PubKey of the Owner passed in its constructor. To resolve the Name any User can now call Get method «Resolve» of DeNS Root locally to obtain an Address. DeNS Root will use Code of NIC smart contract, a DeNS Root PubKey, insert any name they are wishing to resolve into NIC Code and calculate the address. Since most of the time a user application will just cash the Code of NIC smart contract and DeNS PubKey, resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. "},{"title":"Example of NIC smart contract methods​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#example-of-nic-smart-contract-methods","content":"Whois — sends all certificate data: a name, date of registration, owner PubKey GetWhois is a whois getter GetAddress by Type, for example — ADNL, Wallet, RegName GetResolve ChangeAddress ChangeOwnership "},{"title":"Free TON Name Identity Certificate convention​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#free-ton-name-identity-certificate-convention","content":"Format: any alfa-numeric string except for a dot (.) and slash (/) which are prohibited. Only top level names are provided by DeNS Root, but any NIC smart contract can point into a next level of hierarchy which is divided by / top-name/sub-name/ The dot (.) is specifically prohibited as to not create confusions with a current internet domain system. "},{"title":"Example: Ownership Certificate​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#example-ownership-certificate","content":"The Certificate is issued by Root for ownership of an item. Let’s call it certificate of Ownership or COW for short. COW will include a serial number of an item a User want to prove owning. Since the PubKey of an owner of certificate is presented it is easy to prove an ownership of an Item by finding the certificate with corresponding serial number calculating the address of this certificate with this number, POW Code and Root PubKey without a need to maintain any centralized ledger of said items. The transfer of ownership of an Item is easily supported as well by calling a ChangeOwnership Method in the POW signed by the owner private key. "},{"title":"Reference​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"Standard/TIP-2/core-description#reference","content":"Contest Proposal: Decentralized Name Service (DeNS)ReDeNS — Reverse DeCert (TIP-2.1) "},{"title":"DePool Specifications","type":0,"sectionRef":"#","url":"Decentralize/depool-specifications","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#background","content":"It is quite evident that to achieve high-performance properties, a network needs powerful, reliable servers with fast connectivity. At the same time, to achieve sufficient decentralization, these servers have to belong to as many owners as possible. There seems to be a contradiction between these goals. In Proof-of-Work networks, performance is often sacrificed for decentralization. Yet, claims arise that the centralization of Bitcoin, Ethereum etc. mining power is not entirely prevented. Mining Pools centralization remains an issue, as these pools are controlled by particular entities distributing rewards. For example, almost 60% of Bitcoin mining power is concentrated in just 4 pools and around 80% of all mining power originates in China. Just 2 mining pools control 52% of Ethereum hashrate, more than 50% of which originates in China. In Proof-of-Stake, the correlation between network performance and concentration of power (money in this case) is even more apparent, as one does not need to buy, set up, and manage complicated mining farms. It can ultimately be claimed that POS is trading performance for decentralization (look no further than EOS centralization, Steemit network overtaking etc.). It seems that enabling small token holders to participate in network governance is a very important decentralization property. "},{"title":"Motivation​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#motivation","content":"Everscale blockchain needs all newly created blocks to be validated in order to run correctly. For this it relies on special designated nodes called &quot;Validators&quot;, and offers substantial reward for their work. However, becoming a validator requires a substantial cryptocurrency deposit. The required amount might far exceed an individual validator budget. On the other hand, blockchain users with no validating system might be interested in investing in validation duty. This is where the Decentralized Pool (DePool) smart contract comes in. There are two main use cases of DePool: User has no Validator capabilities but some free funds. User can support a third-party Validator and receive rewards.User has Validator capabilities and but doesn't have necessary amount of funds to participate in validator elections and subsequent rewards. "},{"title":"Basic terms​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#basic-terms","content":"DePool — a smart contract that allows other smart contracts to invest stakes into a common pool of funds and after some period of time to receive it back with interest.Elector — a system level smart contract, deployed to masterchain from zero state. Runs validator elections periodically.DePool Proxy (proxy) — a smart contract that delivers messages between DePool and Elector.Participant — a smart contract that invests funds into DePool.Validator — software running blockchain node. Each DePool works with one node only. This node must be a DePool participant.Validator wallet — a smart contract that is used by Validator to send election requests to DePool and receive the Validator reward. Validator wallet should be a Multisig contract with 3 custodians.DePool Helper — a smart contract that stores the address of the actual DePool and works with the Timer contract.Global Validators Set (GVS) — current set of validators chosen in the latest elections.Validation period — period of time for which GVS is elected.Investment round — period of time between Participant investing a stake in DePool and receiving it back (with or without interest).Timer — a smart contract that can call other smart contracts periodically. "},{"title":"Architecture​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#architecture","content":" DePool is designed to receive investment stakes from Participants, allocate the pool funds to a validator in order to participate in elections of the GVS and, after the end of the validation cycle, distribute stakes with certain rewards back to the Participants.DePool is deployed to basechain. But it cannot communicate with Elector directly, because Elector rejects messages from non-masterchain contracts. Thus there are DePool proxies that are deployed to masterchain and deliver messages from DePool to Elector and back. This is done, because DePool is a large and complex contract, and gas and storage fees are 10 times lower in basechain compared to masterchain. Keeping DePool on masterchain would be unreasonably expensive.DePool is open for Participants’ stakes at all times, however, there is a deadline for participation in the upcoming elections. The deadline depends on the timer of the Elector. After the deadline, the incoming stakes will be accumulated for participation in the next elections.DePool distinguishes stakes received before the deadline and after the deadline, therefore it stores information on Participant stakes in separate investment rounds (or rounds), one for every elections, to facilitate subsequent distribution of stakes and rewards. To separate Elector communication, DePool uses 2 proxies: one for even rounds, one for odd.In order to be time-aware, the DePool should be called from time to time. For this purpose the Timer contract is used. DePool Helper asks Timer to call it periodically and transmits every call from Timer to DePool. Interval between calls is chosen according to the elections interval.DePool must be linked to a validator wallet to participate in elections on behalf of the latter. This validator wallet address is specified during DePool deployment and cannot be changed afterwards. When elections start, DePool waits for signed election requests from linked wallet, then attaches round stake to request and transmits it to Elector.Validator can validate many DePools with 1 Validator wallet. Reputation of Validator wallet therefore is available and can be analyzed over time.To ensure that the validator will perform its functions correctly (be always online and not &quot;lie&quot; to other validators), the validator wallet must itself become a Participant and invest in every investment round at least m_validatorAssurance, which is initialized in DePool constructor. This can be achieved with any of the three available types of stakes.When Elector unfreezes validator stakes, DePool returns its stake back with round rewards. Part of the total reward is used to top up the DePool's own balance to a certain value. The rest is distributed as follows: m_validatorRewardFraction% goes to Validator wallet balance. m_participantRewardFraction% is distributed among all Participants in investment round (validator is also participant). m_associationRewardFraction% (can be equal to zero) goes to m_association address.DePool keeps a balance for each Participant and can automatically reinvest Participant's stake into the next investment round if appropriate flag is enabled.Participant can transfer part of its total stake to another Participant's stake inside DePool storage. This function allows for collateralization of the stake to provide liquidity to stake holders. "},{"title":"Special kinds of stakes​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#special-kinds-of-stakes","content":"Along with the basic ordinary stake, that functions according to the rules detailed above, there are 2 types of special stakes: vesting and lock stake. While the entire ordinary stake is invested into the current pooling round (and will thus be reinvested every second round), lock and vesting stakes are split into two equal parts upon reception, which are invested into the current pooling round, and the next round. This way they can be continuously reinvested into both odd and even rounds. "},{"title":"Vesting Stake​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#vesting-stake","content":"Any address can make a vesting stake and define a target participant address (beneficiary) who will own this stake. But not the whole stake is available to the beneficiary at once. Instead it is split into logical parts and the next part of stake becomes available to the participant only when next vesting period is ended. At completion step of every round DePool decides how many vesting parts should be unlocked and subtracted from vesting stake and become available to owner since last unlocking. These funds are added to beneficiary's ordinary stake. Example: address A makes a vesting stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address B and 110 tons are still locked in the pool. After 1 year vesting stake will be equal to 0 and last 10 tons will become available to owner. Vesting for validator beneficiaries is subject to additional rules: At the end of every withdrawal period, the part of the vesting stake to be released is divided proportionally into 2 parts — for rounds in this period when DePool successfully completed validation and received a reward (without slashing) and for rounds when DePool missed elections or was slashed. The portion of the stake corresponding to the successful rounds is sent to the validator, while the portion corresponding to the failed rounds is returned to the vesting stake owner. For example, if there were 100 rounds within the withdrawal period, and DePool successfully completed 80 of them, missed elections in 5 more and was slashed in the remaining 15, the validator will receive 80% of the unlocked part of the vesting stake, and the stake owner will get back 20% of it. "},{"title":"Lock Stake​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#lock-stake","content":"Any address can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (beneficiary). At the end of a period the Lock Stake should be returned to the address which locked it. Example: address A makes a lock stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address A (as opposed to vesting, where these 10 tons would become available to address B, the beneficiary) and 110 tons are still locked in round. DePool will reinvest the gradually diminishing lock stake for a 1 year and pay rewards to B address. After 1 year DePool will return the remainder of the lock stake to address A. One Participant can be a beneficiary only of one lock and one vesting stake. Once current lock or vesting stake of the participant expires, it can be repeated. When a stake of either of these types is created, it is split equally into two last rounds, which means that the minimal value for such stake is 2 * minStake + fee. "},{"title":"Specification​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#specification","content":""},{"title":"Data Structures​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#data-structures","content":"DePool contract uses library and inheritance from several simple base contacts to separate functionality and facilitate development and debugging of the contract. The core data set stored by DePool is the following: DePoolLib.sol // Describes contract who deposit stakes in DePool pool struct Participant { // Count of rounds in which participant takes a part uint8 roundQty; // Sum of all rewards from completed rounds (for logging) uint64 reward; // count of parts of vesting stakes in the rounds uint8 vestingParts; // count of parts of lock stakes in the rounds uint8 lockParts; // Flag whether to reinvest ordinary stakes and rewards bool reinvest; // Target tons that will be transferred to participant after rounds are completed // After each round this value is decreased uint64 withdrawValue; } // Request for elections from validator wallet. struct Request { // Random query id. uint64 queryId; // Validator's public key that will be used as validator key if validator will win elections. uint256 validatorKey; // current election id. uint32 stakeAt; // Validator's stake factor. uint32 maxFactor; // Validator's address in adnl overlay network. uint256 adnlAddr; // Ed25519 signature of above values. bytes signature; }  DePoolRounds.sol // roundPre0 = m_rounds[m_roundQty - 1] — pre-pooling. Helper round for adding vesting and lock // stakes. When vesting/lock stake is added than stake is // split into two part. And first part invested into pooling // round and second part — pre-pooling. // // round0 = m_rounds[m_roundQty - 2] — pooling // round1 = m_rounds[m_roundQty - 3] — election or validation // round2 = m_rounds[m_roundQty - 4] — validation or investigation // Algo of round rotation: // delete round2 // round1 -&gt; round2 // round0 -&gt; round1 // roundPre0 -&gt; round0 // createNewRound -&gt; roundPre0 mapping(uint64 =&gt; Round) m_rounds; // count of created rounds uint64 m_roundQty = 0;  DePoolBase.sol // Dictionary of participants for rounds mapping (address =&gt; Participant) m_participants; // Address of the validator wallet address m_validatorWallet; // Array of proxies addresses. address[] m_proxies;  DePool.sol // Indicates that pool is closed. Closed pool doesn't accept stakes from other contracts. bool m_poolClosed; // Min stake accepted to the pool in nTon (for gas efficiency reasons): 10 tons is recommended. uint64 m_minStake; // Minimum validator stake in each round uint64 m_validatorAssurance; // % of participant rewards uint8 m_participantRewardFraction; // % of validator rewards uint8 m_validatorRewardFraction; // % of dePool association rewards uint8 m_associationRewardFraction; // Association address address m_association; // Minimum balance uint64 m_minimumBalance;  "},{"title":"DePool Initialization​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#depool-initialization","content":"When deployed, the DePool constructor is called with the following parameters: /// @dev DePool's constructor. /// @param minStake Min stake that participant may have in one round. /// @param validatorAssurance Min validator stake. /// @param proxyCode Code of proxy contract. /// @param validatorWallet Address of validator wallet. /// @param participantRewardFraction % of reward that distributed among participants. constructor( uint64 minStake, uint64 validatorAssurance, TvmCell proxyCode, address validatorWallet, uint8 participantRewardFraction, )  At initialization the variable m_balanceThreshold is set as current DePool account balance — 5 tokens. DePool will replenish its balance from validation rewards to this value every round it receives rewards. "},{"title":"Participant functions​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#participant-functions","content":"DePool stores some participant information in a dictionary (m_participants) where key — Participant's address and value — Participant structure. Functions used by participants perform checks and send receiveAnswer message back to the caller with an error code and a comment in case of failure. If all conditions are met, DePool sends a confirmation message (receiveAnswer with status 0) back to the caller. All functions can be called by internal messages only. addOrdinaryStake(uint64 stake) — allows to make an ordinary stake in the current pooling round. The source address of the message is taken as Participant's address. The Participant's total stake is increased by stake amount. Parameters: stake — value of participant's stake in nanotons. Function checks that: inbound message value is at least (stake + ADD_STAKE_FEE);stake is at least min stake;pool is not closed. Function returns change (part of unused ADD_STAKE_FEE). addVestingStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a vesting stake for another participant (beneficiary). The source address of the message is saved as the vesting stake owner. Parameters: stake — value of participant's stake in nanotons (Note: this value is divided into 2 parts and is added to 2 rounds).beneficiary — address of target participant (beneficiary);withdrawalPeriod — the period in seconds after which the part of the vesting becomes available for beneficiary;totalPeriod — total period of vesting in seconds after which beneficiary becomes owner of the whole stake. Function checks that: DePool is not closed (m_poolClosed ≠ true);beneficiary is an addr_std. It's not zero address. It's not the message sender (not self vesting);inbound msg.value ≥ (m_minStake + ADD_STAKE_FEE);Message value is at least stake + STAKE_FEE;stake / 2 is at least min stake;withdrawalPeriod ≤ totalPeriod;totalPeriod &lt; 18 years;withdrawalPeriod ≠ 0;totalPeriod % withdrawalPeriod = 0;beneficiary doesn't have a vesting stake. addLockStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a stake that will bring rewards to another participant (beneficiary). The source address of the message is saved as the lock stake owner. It has the same parameters and checks as addVestingStake, but it checks that participant doesn't have a lock stake instead of a vesting stake. withdrawFromPoolingRound(uint64 withdrawValue) — allows to remove Participant's stake from the current pooling round. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: inbound msg.sender address is address of an existing participant. If real ordinary stake is less than withdrawValue, then DePool returns the whole stake from pooling round. If the remaining stake in the pooling round is less than m_minStake, then the whole stake is transferred to Participant. If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. withdrawPart(uint64 withdrawValue) — Allows a participant to withdraw some value from DePool. This function withdraws withdrawValue nanotons when rounds are completed. If participant stake becomes less than minStake, then the whole stake is sent to participant. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. If the remaining stake in the round is less than m_minStake, then the whole stake will be transferred to Participant (after completing round). If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. 6. withdrawAll() — Set global flag for the participant that indicates to return participant's ordinary stake after completing rounds. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. After transferring all Participant's stake, the Participant will be removed from the m_stakeholders dictionary. cancelWithdrawal() — Cancel effect of calls of functions withdrawAll and withdrawPart. transferStake(address dest, uint64 amount) — allows to move amount of stake from msg.sender Participant to dest Participant inside DePool storage. Parameters: dest — stake beneficiary;amount — stake value transferred to dest in nanotons. Function checks that: pool is not closed (m_poolClosed ≠ true);destination is a non-zero addr_std;msg.sender ≠ dest;neither destination nor msg.sender is the validator wallet;inbound msg.sender address is address of an existing participant;desired amount can be transferred and transfer doesn't leave stake less than m_minStake in any round. In case of success DePool sends back a notification via onTransfer function calling to beneficiary. "},{"title":"Functions of interface DePoolInfoGetter:​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#functions-of-interface-depoolinfogetter","content":"function getLastRoundInfo() public If there is no completed round yet, call callback function receiveDePoolInfo with struct containing default values, else send call with struct containing info about last completed round. // Represent info about last completed round struct LastRoundInfo { uint32 supposedElectedAt; uint8 participantRewardFraction; uint8 validatorRewardFraction; uint32 participantQty; uint64 roundStake; address validatorWallet; uint256 validatorPubkey; uint64 validatorAssurance; }  "},{"title":"Participant callback functions:​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#participant-callback-functions","content":"These functions are called by DePool to send notifications to Participant. receiveAnswer(uint32 errcode, uint64 comment) — function, which is called as an answer from DePool to Participant. Arguments: errcode — error code. List of codes: uint8 constant STATUS_SUCCESS = 0; uint8 constant STATUS_STAKE_TOO_SMALL = 1; uint8 constant STATUS_DEPOOL_CLOSED = 3; uint8 constant STATUS_NO_PARTICIPANT = 6; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_VESTING = 9; uint8 constant STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD = 10; uint8 constant STATUS_TOTAL_PERIOD_MORE_18YEARS = 11; uint8 constant STATUS_WITHDRAWAL_PERIOD_IS_ZERO = 12; uint8 constant STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD = 13; uint8 constant STATUS_PERIOD_PAYMENT_IS_ZERO = 14; uint8 constant STATUS_REMAINING_STAKE_LESS_THAN_MINIMAL = 16; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_LOCK = 17; uint8 constant STATUS_TRANSFER_AMOUNT_IS_TOO_BIG = 18; uint8 constant STATUS_TRANSFER_SELF = 19; uint8 constant STATUS_TRANSFER_TO_OR_FROM_VALIDATOR = 20; uint8 constant STATUS_FEE_TOO_SMALL = 21; uint8 constant STATUS_INVALID_ADDRESS = 22; uint8 constant STATUS_INVALID_BENEFICIARY = 23; uint8 constant STATUS_NO_ELECTION_ROUND = 24; uint8 constant STATUS_INVALID_ELECTION_ID = 25;  comment — some value attached to error code. onTransfer(address source, uint128 amount) — function, which is called after successful transferStake to inform beneficiary. Arguments: source — address of Participant who made transfer;amount — funds that were transferred. onRoundComplete(uint64 roundId, uint64 reward, uint64 ordinaryStake, uint64 vestingStake, uint64 lockStake, bool reinvest, uint8 reason) — send a notification from DePool to Participant when round is completed: roundId — Id of completed round;reward — Participant's reward in completed round in nanotons;ordinaryStake — ordinary stake in completed round;vestingStake — vesting stake in completed round;lockStake — lock stake in completed round;reinvest — are ordinary stakes automatically reinvested (prolonged)?reason — reason why round is completed (See enum CompletionReason). "},{"title":"DePool owner functions:​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#depool-owner-functions","content":"These functions can be called only by the DePool owner, as they have to be signed with the deploy keypair. terminator() [external msg only] — a method to close DePool. All stakes from all rounds are returned in several phases: a. first of all, stakes from pooling round are returned immediately. b.m_poolClosed = true; c. All other rounds will return stakes after their &quot;completed&quot; step. Important: remaining parts of vesting/lock stakes will be sent to owners of those stakes (not to beneficiaries) setValidatorRewardFraction(uint8 fraction) [external msg only] Sets new validator's reward fraction and calculates new participants' reward fraction. New validator's reward fraction must be less than current one and be not zero. fraction — new validator's reward fraction. "},{"title":"Events​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#events","content":"DePoolClosed() — event emitted when pool is closed by terminator() function.RoundStakeIsAccepted(uint64 queryId, uint32 comment) — event is emitted on accepting stake by elector.RoundStakeIsRejected(uint64 queryId, uint32 comment) — event is emitted on rejecting stake by elector.ProxyHasRejectedTheStake(uint64 queryId) — event is emitted if stake is returned by proxy (IProxy.process_new_stake) because too low balance of proxy contract.ProxyHasRejectedRecoverRequest(uint64 roundId) — event is emitted if stake cannot be returned from elector (IProxy.recover_stake) because too low balance of proxy contract.RoundCompleted(TruncatedRound round) — event is emitted on completing round.StakeSigningRequested(uint32 electionId, address proxy) — Event emitted when round is switched from pooling to election. DePool is waiting for signed election request from validator wallet.TooLowDePoolBalance(uint replenishment) — event emitted when pure DePool's balance becomes too low. replenishment minimal value that must be sent to DePool via receiveFunds function.RewardFractionsChanged(uint8 validator, uint8 participants) — event emitted when contract owner changes reward fractions. validator — validator's reward fraction. participants — participants' reward fraction. "},{"title":"Get-methods​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#get-methods","content":"These get-methods are used for local run. getParticipantInfo(address addr) — returns participant's information about stakes in every rounds;getDePoolInfo() — returns DePool configuration parameters and constants;getParticipants() — return list of all participants;getRounds() — returns information about all rounds.getDePoolBalance() — returns DePool's own balance in nanotokens. The DePool does not store validator public keys or ADNL address, because, according to the official Everscale guide, the Validator generates a new keypair and ADNL for every elections. The contract stores only Validator wallet address. "},{"title":"State update function​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#state-update-function","content":"ticktock() — this function is the &quot;engine&quot; of DePool. This function rotates rounds: creates a new round if necessary and removes an old one. Switches steps of rounds and calls various internal functions if certain conditions are satisfied and so on. ticktock() — does not accept external inbound messages and can be called only from other contracts ticktock returns unspent message value (change) back to caller. "},{"title":"Multi-Round elections​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#multi-round-elections","content":" Every round goes through several steps: &quot;PrePooling&quot; step (RoundStep.PrePooling) — it's an imaginary round introduced to store half of vesting/lock stake from participants. See addVestingStake/addLockStake functions.&quot;Pooling&quot; step (RoundStep.Pooling) — round is ready to accept stakes from Participants. This round receives ordinary, vesting and lock stakes.&quot;waiting for election requests&quot; step (RoundStep.WaitingValidatorRequest) — round is switched to this step when validator elections begin. DePool is waiting for signed election request from validator wallet. See process_new_stake function of Elector to properly generate election request. Important: Validator wallet must also be a Participant and invest at least m_validatorAssurance stake in the round. If it doesn't, round is completed and stakes are reinvested in another round or are returned to participants. &quot;Waiting if stake is accepted by elector&quot; (RoundStep.WaitingIfStakeAccepted) — DePool has received the validator signed election request. DePool has sent the whole round stake to elector through one of its proxies. Now DePool is waiting for elector answer. Note: elector will call DePool's onStakeAccept function if election request is accepted successfully or onStakeReject in case of an error.&quot;waiting for validation start&quot; (RoundStep.WaitingValidationStart) — round stake was accepted by elector. Validator is a candidate. DePool now is waiting for the start of the validation to find out if validator won the elections.&quot;waiting for election result&quot; (RoundStep.WaitingIfValidatorWinElections) — DePool has tried to recover stake in validation period to find out if validator won elections. Waiting for elector answer. Note: If validator won the elections, elector returns no stake. If Validator lost the elections, elector returns the whole stake.&quot;waiting stake unfreeze&quot; (RoundStep.WaitingUnfreeze) — If CompletionReason != Undefined, the round is waiting round rotation to return/reinvest funds because elections were lost. Else validator won elections. DePool is waiting for ending of unfreeze period to recover funds from elector.&quot;waiting for a reward&quot; (RoundStep.WaitingReward) — Unfreeze period has been ended. Request to recover stake has been sent to elector. DePool is waiting for answer from elector.&quot;completing&quot; step (RoundStep.Completing) — DePool receives reward and replenishes its balance from it. Then it returns or reinvests participant's stakes. Also on this step DePool recounts vesting and lock stakes and modifies them if necessary.&quot;completed&quot; (RoundStep.Completed) — round switches to this step after processing all the Participants in the round. In next ticktock this round will be deleted. "},{"title":"Round completion​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#round-completion","content":"When a round switches to &quot;completing&quot; step (completeRound function), the DePool replenishes its balance from received rewards and then starts to cycle through all stakes in the round. If Participant's reinvestment flag is false, DePool sends it back to the Participant, otherwise — adds it to the pooling round. Also DePool sends notification message (onRoundComplete) to Participant. DePool goes through all vesting and lock stakes of the completing round and checks whether a withdrawal period has finished for the current stake. If it has, DePool modifies the stake via transferring part of it to Participants ordinary stake (in case of Vesting) and/or transferring part of the stake back to the owner (in case of Lock or in case of Vesting for validator which was slashed or lost elections over the course of the completed withdrawal period). Remark: if there are 15000 stakes in round, then the contract should split completion to 375 transactions sending 375 completePendingRound messages to itself. All these transactions can fit in 1-2 blocks and the whole operation will take about 5-20 seconds. "},{"title":"DePool decentralization​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#depool-decentralization","content":"No inherent way to replace the contract code (no SETCODE);No inherent way to transfer an arbitrary amount of currency from the DePool;Any contract can call the ticktock() function to update the state of the DePool;No one has special privileges, except for deployer of DePool who can only close DePool and start a procedure of returning all stakes back to Participants;Fees cannot be changed after the contract is deployed;Validator wallet must be a Participant as well to share risks with other Participants. "},{"title":"DePool contract fee​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#depool-contract-fee","content":"Caller of DePool's ticktock function must pay for consumed gas. Unused message value is returned back when ticktock is finished. At the beginning of completing step DePool first takes from the total reward an amount of tokens to replenish it's balance to m_balanceThreshold, and then additionally RET_OR_REINV_FEE * (N + 1), where N is the number of participants, to cover the costs of stake processing. "},{"title":"Links​","type":1,"pageTitle":"DePool Specifications","url":"Decentralize/depool-specifications#links","content":"DePool contract is available on github. DePool deployment instructions can be found here. "},{"title":"DeBot Specifications","type":0,"sectionRef":"#","url":"Decentralize/debot-specifications","content":"","keywords":""},{"title":"Objective​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#objective","content":"Provide a secure and convenient environment to work with smart-contracts emulate calling smart-contract functions locally on the client;debug blockchain transactions;interact with smart-contracts deployed in the blockchain. "},{"title":"Basic terms​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#basic-terms","content":"DeBot — a smart contract facilitating conversation-like flow communication with a target smart contract;Target smart contract — a smart contract for which DeBot is created. DeBot is an interface to this smart contract;DeBot protocol — a set of rules describing the communication between browser and DeBot: how to call DeBot functions and how to interpret its answers;DeBot engine (DEngine) — a program component that executes DeBot and parses its answer using DeBot protocol;DeBot browser — a program, which creates instances of DEngine for executed DeBot and renders the user interface. "},{"title":"Architecture​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#architecture","content":" DeBot platform consists of the following elements: DeBot smart contract;DeBot browser;Target smart contract(s). One target smart contract can have several DeBot and vise versa. DeBot is deployed to the blockchain. DeBot browser runs on client. It downloads DeBot code and runs it inside the DEngine. "},{"title":"Proof of State​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#proof-of-state","content":"Transactions can be verified by running DeBot locally and comparing the result of execution to the account state in the blockchain. "},{"title":"DeBot Interfaces​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#debot-interfaces","content":""},{"title":"Motivation​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#motivation","content":"DeBot is a smart contract and smart contracts are isolated from each other and from the blockchain, their capabilities are limited by the commands of the virtual machine on which they are executed. But DeBot must have more possibilities. DeBot need to: receive input from users;query info about other smart contracts;query transactions and messages;receive data from external subsystems (like file system) and external devices (like NFC, camera and so on);call external function libraries that allow to do operations that are not supported by VM. For example, work with json, convert numbers to string and vice versa, encrypt/decrypt/sign data. To cover all these needs we should design different DeBot Interfaces (DInterfaces) which can be used in DeBot and which must be supported in DeBot Browsers. These interfaces should match the requirements: comprehensive — interfaces should describe all types of communication accessible on modern devices;universal — interfaces should be abstract from certain OS and hardware;atomic — every communication channel should be separately described in the interface for further flexible resource access management;convenient — even low-skilled developers should be able to use this interface in their DeBot. In this model DeBot Engine should act like a proxy between DeBot Browser and DeBot. But it can have builtin implementation of very basic DInterfaces (e.g. working with json). Also, we need to describe the manifest for DeBot. DeBot developer will describe all needed interfaces in this manifest and the DeBot Browser will check it before running DeBot. We need this manifest to keep users secure and private when using DeBot. "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#description","content":"Every DeBot must declare which DInterfaces it will use. For this purpose it must have getRequiredInterfaces() function which returns array of required interfaces. Every interface must have an id which is an unsigned 256-bit integer and an address which is used in DeBot as a destination address of internal messages. Address must be a standard Everscale address consisting of DEBOT_WC (equal to 0xDB) as a workchain_id part and interface id as address part (see &quot;Telegram Open Network Blockchain&quot;specification, section 3.1.2 for details about TL-B scheme for address). For example, in solidity getRequiredInterfaces can be implemented like this: // Base contract for all DeBot abstract contract Debot { i32 constant DEBOT_WC = - 31; function getRequiredInterfaces() virtual returns (uint256[] interfaces); } contract DebotA is Debot { function getRequiredInterfaces() override returns (uint256[] interfaces) { return [ID_TERMINAL, ID_MENU, ...]; } }  "},{"title":"How to use DInterface in DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#how-to-use-dinterface-in-debot","content":"To use an interface DeBot should import source file with DInterface declaration and call its methods as any other smart contract methods in Everscale — by sending internal messages to interface address. Before running the DeBot, DeBot Browser should provide callbacks for DEngine to receive all requests to DInterfaces. Requests are packed into internal messages. When Browser receives a message from DEngine it should unpack the message, decode its body, call DInterface function, pack results to internal message and return it to DEngine using Dengine.send(msg). interface BrowserCallbacks { // Message from Debot to Browser with encoded DInterface call send(message: string): Promise&lt;void&gt; // Request from DEngine to approve some action (for example, send mesage to blockchain) approve(action: {}): boolean // Request from DeBot to call another DeBot invoke(debotAddress: string, message: string): Promise&lt;void&gt; }  "},{"title":"DeBot Start​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#debot-start","content":"Befor starting DeBot should also provide metadata, which includes its name, version, authorship information, description, language and ABI. This is accomplished through the getDebotInfo() mandatory function. Along with getRequiredInterfaces() this function is defined in the base contract Debot.sol. // Base contract for all DeBots abstract contract Debot { /// @notice ACTION structure struct Action { // String that describes action step, should be printed to user string desc; // Name of debot function that runs this action string name; // Action type uint8 actionType; // Action attributes. // Syntax: &quot;attr1,attr2,attr3=value,...&quot;. // Example: &quot;instant,fargs=fooFunc,sign=by-user,func=foo&quot; string attrs; // Context to transit to uint8 to; // Action internal data TvmCell misc; } struct Context { uint8 id; // Context ordinal string desc; // message to be printed to the user Action[] actions; // list of actions } string s_dabi; /* * Public debot interface */ /// @notice Returns list of interfaces used by DeBot. function getRequiredInterfaces() public view virtual returns (uint256[] interfaces); /// @notice Used for error handling for external messages if error code &gt;= 400 (TVM) and &lt; 500 (PROCESSING) function getErrorDescription(uint32 error) public pure virtual returns (string desc); /// @notice Invoked by DeBot Browser at debot startup. Returns array of debot contexts. function fetch() public virtual returns (Context[] contexts); /// @notice DeBot entry point. function start() public virtual; /// @notice Returns DeBot metadata. /// @return name String with name of debot, e.g. &quot;DePool&quot;. /// @return version Semver version of debot, that will be converted to string like &quot;x.y.z&quot;. /// @return publisher String with info about who has deployed debot to blokchain, e.g. &quot;TON Labs&quot;. /// @return caption (10-20 ch.) String with short description, e.g. &quot;Work with Smthg&quot;. /// @return author String with name of author of DeBot, e.g. &quot;Ivan Ivanov&quot;. /// @return support Free TON address of author for questions and donations. /// @return hello String with first messsage with DeBot description. /// @return language (ISO-639) String with debot interface language, e.g. &quot;en&quot;. /// @return dabi String with debot ABI. function getDebotInfo() public functionID(0xDEB) view virtual returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ); /// @notice Allow to set debot ABI. Do it before using debot. function setABI(string dabi) public { require(tvm.pubkey() == msg.pubkey(), 100); tvm.accept(); s_dabi = dabi; } /// @notice Returns DeBot ABI. /// @dev Deprecated. Remove later. https://github.com/tonlabs/TON-SDK/blob/dc0631a726295c4e7190361c417214c301ec4e01/ton_client/src/debot/dengine.rs#L175 function getDebotOptions() public view returns ( uint8 options, string debotAbi, string targetAbi, address targetAddr ) { debotAbi = s_dabi; targetAbi = &quot;&quot;; targetAddr = address(0); options = 1; } } contract MyDeBot is Debot { function getErrorDescription(uint32 error) public pure override returns (string desc) { tvm.log(format(&quot;getErrorDescription: {}&quot;, error)); desc = format(&quot;some description about code {}&quot;, error); // TODO description error codes } function fetch() public override returns (Context[] contexts) { tvm.log(&quot;fetch&quot;); // TODO fetch Context } function start() public override { tvm.log(&quot;start&quot;); // TODO start } function getDebotInfo() public functionID(0xDEB) view override returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ) { tvm.log(&quot;getDebotInfo&quot;); name = &quot;MyDeBot&quot;; version = &quot;1.0.0-alpha.0&quot;; publisher = &quot;Everscale&quot;; caption = &quot;My first DeBot&quot;; author = &quot;Everscale&quot;; support = address.makeAddrStd(0, 0x0); hello = &quot;Hello first user!&quot;; language = &quot;en&quot;; dabi = s_dabi; icon = &quot;&quot;; } function getRequiredInterfaces() public view override returns (uint256[] interfaces) { tvm.log(&quot;getRequiredInterfaces&quot;); // TODO add dependency interfaces } }  Run debug log: npx tonos-cli debot --debug fetch &lt;ADDRESS&gt; 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getRequiredInterfaces 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getDebotInfo 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] fetch DeBot Info: Name : MyDeBot Version: 1.0.0-alpha.0 Author : Everscale Publisher: Everscale Support: 0:0000000000000000000000000000000000000000000000000000000000000000 Description: My first DeBot Hello first user! Run the DeBot (y/n)? y 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getRequiredInterfaces 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getDebotInfo 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] fetch 19:44:02 [DEBUG] (1) ton_client::debot::dengine: switching to 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: switched to ctx 0 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_action: start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external start, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running start, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: instant_switch = false, state_to = 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: no more actions, exit loop  Before starting the DeBot, DeBot Browser creates new instance of DEngine with address of DeBot;DEngine downloads DeBot state, queries metadata and list of DInterfaces required by DeBot and returns the list to Browser;Browser must check that it supports all required DInterfaces. If one of interfaces is not supported, Browser must report error to the user (application) and not start the DeBot otherwise Browser must list requested interfaces to user (application);All required interfaces should be approved by user (application);After the list of interfaces is approved, the DeBot Browser starts DeBot using Dengine.start(callback). On every interface call Browser should check permission for DeBot and on success execute it according to isolation requirement if needed. Below you can see DeBot start sequence:  "},{"title":"DInterface specification​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#dinterface-specification","content":"Every DInterface must be discussed and accepted by DeBot Interface Specifications (DIS) Consortium before it can be used in DeBot. All accepted interfaces are published in repo: https://github.com/tonlabs/DeBot-IS-consortium Everybody can suggest new DInterface. Go to repo and follow the instructions. "},{"title":"DInterfaces support in DeBot Browser​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#dinterfaces-support-in-debot-browser","content":"DeBot Browser can support and implement any or all DInterfaces published in DIS repo depending on browser's capabilities. For example, console browser cannot support external devices like camera, NFC, microphone and so on. Some interfaces required for basic DeBot operation are built into the DEngine itself (SDK, Hex, JsonDeserialize). They are marked as such in their respective readme files in the IS consortium repository. "},{"title":"DEngine versioning​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#dengine-versioning","content":"DEngine as a SDK module should have a version of SDK itself. DIS statuses: Proposed, Accepted, Published. "},{"title":"Example of DInterface​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#example-of-dinterface","content":"Name\tIDRawInput\t8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#description-1","content":"Allows to get string from user "},{"title":"Functions​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#functions","content":"Function input arguments: answerId: uint32 — function id of result callbackprompt: bytes — string printed to the user and describing what to enter returns: text: bytes — string entered by user "},{"title":"Declaration in Solidity​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#declaration-in-solidity","content":"interface IRawInput { function input(uint32 answerId, string prompt) external returns (string value); } Library RawInput { uint256 constant ID_RAWINPUT = 0x8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 // Callback Function Prototype function inputResult(uint32 answerId, string prompt) public { address addr = address.makeAddrStd(DEBOT_WC, ID_RAWINPUT); IRawInput(addr).input(answerId, prompt); } }  "},{"title":"Declaration in C++​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#declaration-in-c","content":"namespace tvm { namespace schema { __interface IRawInput { [[internal, answer_id]] string input(string prompt); };  "},{"title":"Code Example​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#code-example","content":"Solidity​ pragma solidity &gt;=0.6.0; import &quot;Debot.sol&quot;; import &quot;RawInput.sol&quot;; contract ExampleDebot is Debot, RawInput { function start() public { RawInput.input(tvm.functionId(inputResult), &quot;enter your name:&quot;); RawInput.input(tvm.functionId(inputResult), &quot;enter your wallet address:&quot;); } function inputResult(string text) public override { require(text == &quot;Debot&quot;); } }  Note: C++ DeBot are currently in the state of early development, and not all features all completely defined for them yet. "},{"title":"DeBot Special Features​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#debot-special-features","content":"DeBot have 3 special features: calling — get-methods of target smart contracts;calling — external functions of target smart contracts onchain;invoking — other DeBot in a local environment. Ordinary Everscale smart contracts cannot use 1st and 2nd features because they cannot produce external inbound messages. But DeBot can, due to the fact that they are executed in DEngine, that allows DeBot to generate these kinds of messages, send them to blockchain and return results to DeBot. In terms of DeBot, all these features are implemented without DInterfaces but in a native way, like two smart contracts communicating with each other — by sending messages directly to target address. But with only one difference — to call a get-method or call a function onchain DeBot must generate external inbound message, while to invoke another DeBot, it should generate an internal message to the invoked DeBot address. DEngine distinguishes between get-methods and onchain calls by examining the sign header of the message. Signed messages (sign: true) are considered onchain calls, while unsigned messages (sign: false) are considered to be get-method calls. "},{"title":"Get-methods​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#get-methods","content":"Developer Example​ Solidity function showTasks(uint32 index) public view { index = index; optional(uint256) none; ITodo(m_address).getTasks{ abiVer: 2, extMsg: true, sign: false, pubkey: none, time: uint64(now), expire: 0, callbackId: tvm.functionId(showTasks_), onErrorId: tvm.functionId(onError) }(); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If yes, then DEngine analyzes each message by scanning signature and public key bits in message body to understand if message is for get-method call. If bits are zero DEngine downloads target contract and runs its get-method, then returns results to DeBot by calling its function set in the callbackId or onErrorId (in case of errors) headers of message body. "},{"title":"Onchain function call​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#onchain-function-call","content":"Developer example​ Solidity IMsig(m_msigAddress).sendTransaction{ abiVer: 2, extMsg: true, sign: true, pubkey: pubkey, time: uint64(now), expire: 0, callbackId: tvm.functionId(waitBeforeDeploy), onErrorId: tvm.functionId(onErrorRepeatCredit) }(m_address, INITIAL_BALANCE, false, 3, empty); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If there is one, DEngine analyzes if it is onchain call by scanning signature and public key bits in message body. If signature bit is 1 then DEngine does the following things. Downloads target smart contract, signs the message and emulates its transaction locally;Checks if transaction produces outbound internal messages with funds;Requests permission from DeBot Browser to send this message onchain. Request contains information about funds that will be spent if message will be executed onchain and message itself;If DeBot Browser allows to send message, DEngine sends message to blockchain. "},{"title":"Invoking DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#invoking-debot","content":"DeBot can call another DeBot by simply sending internal message to it. After DeBot execution DEngine filters all internal messages produced by DeBot with destination addresses with workchain 0. This filter allows to separate DInterface calls (which have 0xDB workchain id) from DeBot invokes. If there are invoke messages, DEngine sends them to Browser through BrowserCallbacks interface. Browser (or user) has to approve the invoke of a new DeBot, at which point Browser creates a new DEngine instance, downloads target DeBot and transfers the message to it. Browsers should generally support a common queue for messages from several DeBot. "},{"title":"Security notes​","type":1,"pageTitle":"DeBot Specifications","url":"Decentralize/debot-specifications#security-notes","content":"At start browser creates a DEngine instance, and receives DeBot metadata and list of required DInterfaces through DEngine, and checks them for compatibility and security. When DeBot is running, DEngine proxies all DInterface calls (except calls to builtin interfaces supported by engine itself like SDK calls) directly to Browser which must decide to execute or reject them. Get-method calls are always allowed. Executed by DEngine. External function calls must be approved by Browser. Executed by DEngine. Other DeBot calls are always allowed. But executed by Browser which can block invoke if needed. "},{"title":"Fungible Token Interface (TIP-3.1)","type":0,"sectionRef":"#","url":"Standard/TIP-3/1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"Standard/TIP-3/1#abstract","content":"The following standard allows for the implementation of a standard API for tokens within smart contracts. General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"Standard/TIP-3/1#motivation","content":"A standard interface allows any tokens on Everscale to be re-used by other applications: from wallets to decentralized exchanges. "},{"title":"Specification​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"Standard/TIP-3/1#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. "},{"title":"Notes​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"Standard/TIP-3/1#notes","content":"We choose Standard Interface Detection to expose the interfaces that a TIP3 smart contract supports.This standard does not define the external methods to initiate transfer, mint or burn tokens. Though it defines the methods, which MUST be called on a recipient token wallet or token root during these operations.The rules for a token wallet ownership MUST be defined in a child standards.A -1 offset is added to some function IDs derivations, so the preimage of the hash cannot be known, further reducing the chances of a possible collisions. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"Standard/TIP-3/1#token-root","content":"Name​ Returns the name of the token - e.g. &quot;MyToken&quot;. function name() public view responsible returns (string);  Symbol​ Returns the symbol of the token. E.g. “HIX”. function symbol() public view responsible returns (string);  Decimals​ Returns the number of decimals the token uses - e.g. 8, means to divide the token amount by 100000000 to get its user representation. function decimals() public view responsible returns (uint8);  Total supply​ Returns the total token supply. function totalSupply() public view responsible returns (uint128);  Token wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens burn​ Does not have a standard signature, but has a standard function ID 0x192B51B1 obtained as tvm.functionId('acceptBurn(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Decreases token total supply by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptBurn { function acceptBurn(uint128 _value) functionID(0x192B51B1) public; function acceptBurn2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x192B51B1) public; function acceptBurn3(uint128 _value, TvmCell _meta) functionID(0x192B51B1) public; }  Standard interface detection​ interface TIP3TokenRoot { function acceptBurn(uint128 _value) functionID(0x192B51B1) public view responsible; function name() public view responsible returns (string); function symbol() public view responsible returns (string); function decimals() public view responsible returns (uint8); function totalSupply() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token root interface ID is 0x4371D8ED. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"Standard/TIP-3/1#token-wallet","content":"Root​ Returns the token root address. function root() public view responsible returns (address);  Balance​ Returns the token wallet balance. function balance() public view responsible returns (uint128);  Wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens transfer​ Does not have a standard signature, but has a standard function ID 0x67A0B95F obtained as tvm.functionId('acceptTransfer(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the transfer can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptTransfer { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptTransfer2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x67A0B95F) external; function acceptTransfer3(uint128 _value, TvmCell _meta) functionID(0x67A0B95F) external; }  Accept tokens mint​ Does not have a standard signature, but has a standard function ID 0x4384F298 obtained as tvm.functionId('acceptMint(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token root. Before sending this message, token root MUST increase the total supply by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptMint { function acceptMint(uint128 _value) functionID(0x4384F298) external; function acceptMint2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x4384F298) external; function acceptMint3(uint128 _value, TvmCell _meta) functionID(0x4384F298) external; }  On-bounce behaviour​ The acceptTransfer or acceptBurn methods can be bounced, e.g. receiver token wallet has a different code or burning disabled. The token wallet behaviour in these cases should be implemented according to the following rules. Handle acceptTransfer bounce​ Increases token wallet balance according to the value, specified in the bounce body. Handle acceptBurn bounce​ Increases token wallet balance according to the value, specified in the bounce body. Standard interface detection​ interface TIP3TokenWallet { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptMint(uint128 _value) functionID(0x4384F298) external; function root() public view responsible returns (address); function balance() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token wallet interface ID is 0x4F479FA3. "}]